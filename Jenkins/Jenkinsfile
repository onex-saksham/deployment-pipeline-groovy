// Groovy Scripted Pipeline

node {
    // Define build parameters. These will be automatically read by Jenkins.
    properties([
        parameters([
            choice(name: 'TARGET_ENV', choices: ['Dev', 'QA', 'Prod'], description: 'Select the target environment for deployment.'),
            booleanParam(name: 'DEPLOY_APP_ONE', defaultValue: true, description: 'Deploy Application One?'),
            booleanParam(name: 'DEPLOY_APP_TWO', defaultValue: false, description: 'Deploy Application Two?')
        ])
    ])

    // A try-catch-finally block ensures errors are handled and cleanup always runs
    try {
        // Stage 1: Initialization
        stage('Initialization') {
            echo "Pipeline started for environment: ${params.TARGET_ENV}"
            echo "Deploy App One: ${params.DEPLOY_APP_ONE}, Deploy App Two: ${params.DEPLOY_APP_TWO}"
            // Checkout the source code from the configured Git repository
            checkout scm
        }

        // Stage 2: Parameter Pulling from Git
        stage('Parameter Pulling from Git') {
            echo "Fetching configuration for ${params.TARGET_ENV}..."
            // Copy the environment-specific config files to the workspace root
            sh "cp jenkins/configs/${params.TARGET_ENV.toLowerCase()}/*.json ."
            echo "Configuration files pulled successfully."
        }

        // Stage 3: Parameter Validation
        stage('Parameter Validation') {
            // This stage includes manual approval only for the Production environment
            if (params.TARGET_ENV == 'Prod') {
                echo "Manual approval required for Production."
                timeout(time: 5, unit: 'MINUTES') {
                    input message: "Review deployment details. Proceed with PRODUCTION deployment?", ok: "Yes, Deploy to Production"
                }
            } else {
                echo "Skipping manual approval for non-production environment."
            }
        }

        // Stage 4: Test Cases (Planned)
        stage('Test Cases (Planned)') {
            echo "Placeholder stage for automated tests."
            // Future test script execution will be added here.
        }

        // Stage 5: Deployment Execution
        stage('Deployment Execution') {
            echo "Executing deployment.py script..."
            // Build the command to run the Python script with the correct parameters
            def deployCommand = "python3 deployment.py --environment ${params.TARGET_ENV}"
            if (params.DEPLOY_APP_ONE) {
                deployCommand += " --app-one"
            }
            if (params.DEPLOY_APP_TWO) {
                deployCommand += " --app-two"
            }
            
            // Run the script. The build will fail if the script returns an error.
            sh deployCommand
        }

        // Stage 6: Validation (Planned)
        stage('Validation (Planned)') {
            echo "Placeholder stage for post-deployment validation."
            // Future validation scripts (health checks, etc.) will be added here.
        }

    } catch (e) {
        // This block catches any error from the stages above
        echo "An error occurred during the pipeline execution: ${e.getMessage()}"
        currentBuild.result = 'FAILURE'
        throw e // Re-throw the exception to mark the pipeline as failed
    } finally {
        // This block always runs, ensuring the workspace is cleaned up
        stage('Cleanup') {
            echo "Cleaning up workspace..."
            cleanWs()
        }
    }
}
node {
    // Define the parameters that will be presented to the user in the Jenkins UI
    // when they click "Build with Parameters".
    properties([
        parameters([
            booleanParam(name: 'SMS', defaultValue: false),
            booleanParam(name: 'RCS', defaultValue: false),
            booleanParam(name: 'Whatsapp', defaultValue: false),

            // == Environment and Version Selection ==
            choice(name: 'TARGET_ENV', choices: ['Test', 'Dev', 'Single', 'QA', 'Prod', 'SBI_prod', 'SMPP_DR', 'Functional_Lab'], description: 'Select the target environment for deployment.'),
            string(name: 'DEPLOY_VERSION', defaultValue: '1.0.0', description: 'Enter the version to deploy (e.g., 1.2.3).'),


            // == Service Selection Toggles ==
            booleanParam(name: 'Select_All', defaultValue: false, description: 'Select this to deploy all application services (Zookeeper to Nginx).'),
            booleanParam(name: 'ZOOKEEPER', defaultValue: false),
            booleanParam(name: 'KAFKA', defaultValue: false),
            booleanParam(name: 'NIFI', defaultValue: false),
            booleanParam(name: 'NIFI_REGISTRY', defaultValue: false),
            booleanParam(name: 'DORIS_FE', defaultValue: false),
            booleanParam(name: 'DORIS_BE', defaultValue: false),
            booleanParam(name: 'CONNECT_FE_BE', defaultValue: false),
            booleanParam(name: 'NODE_EXPORTER', defaultValue: false),
            booleanParam(name: 'KAFKA_EXPORTER', defaultValue: false),
            booleanParam(name: 'PROMETHEUS', defaultValue: false),
            booleanParam(name: 'GRAFANA', defaultValue: false),
            booleanParam(name: 'HEALTH_REPORTS', defaultValue: false),
            booleanParam(name: 'RECON', defaultValue: false),
            booleanParam(name: 'JOBS', defaultValue: false),
            booleanParam(name: 'API', defaultValue: false),
            booleanParam(name: 'NGINX', defaultValue: false),
            booleanParam(name: 'SCHEMA_REGISTRY', defaultValue: false)
        ])
    ])

    try {
        // Stage 1: Check out the primary source code (the repo containing this Jenkinsfile).
        stage('Initialization') {
            echo "Pipeline started for environment: ${params.TARGET_ENV}"
            checkout scm
        }

        // REVERT THIS BEFORE PR bring back compelete pull logic back


        // Stage 2: Fetch large binary files ('Releases') from a separate private repository.
        // This uses Git LFS (Large File Storage).
        stage('Gather Source Files') {
            echo "Fetching Releases folder from private repo..."

            dir('temp_private_repo') {
                withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
                    def vaultAddr = "http://localhost:8200"
                    def vaultPath = "secret/data/jenkins/github"

                    def DEVELOPMENT_MODE = true  

                    echo "Fetching GitHub credentials from Vault (${vaultAddr}/v1/${vaultPath})..."

                    def vaultResponse = sh(
                        script: """
                            curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
                                ${vaultAddr}/v1/${vaultPath}
                        """,
                        returnStdout: true
                    ).trim()

                    if (!vaultResponse) {
                        error "Vault returned empty response for path: ${vaultPath}"
                    }

                    def vaultJson = readJSON text: vaultResponse
                    def githubData = vaultJson?.data?.data

                    if (!githubData || !githubData['username'] || !githubData['token']) {
                        error "Missing username/token fields in Vault secret at ${vaultPath}"
                    }

                    def GITHUB_USER = githubData['username']
                    def GITHUB_TOKEN = githubData['token']

                    echo "Successfully retrieved GitHub credentials from Vault."

                    sh "git config --global lfs.https://github.com/1xtel/ODP.git.header 'Authorization: token ${GITHUB_TOKEN}'"

                    // Check if .git already exists (means we've already pulled once)
                    def alreadyPulled = fileExists('.git')

                    if (!alreadyPulled || !DEVELOPMENT_MODE) {
                        echo "Performing full repo pull (LFS included)..."
                        sh "rm -rf .git"

                        def gitUrl = "https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/1xtel/ODP.git"
                        sh """
                            git init
                            git remote add origin ${gitUrl}
                            git config core.sparseCheckout true
                            echo "Jenkins/deployment-pipeline/Releases/" > .git/info/sparse-checkout
                            git lfs install
                            git pull origin main --depth=1
                        """
                    } else {
                        echo "Skipping LFS pull â€” using previously fetched data for faster development runs."
                    }

                    sh "git config --global --unset lfs.https://github.com/1xtel/ODP.git.header"
                }

                echo "Copying Releases folder to the workspace root..."
                sh """
                    mkdir -p ./deployment
                    cp -r Jenkins/deployment-pipeline/Releases ./deployment/
                """

                echo "Successfully loaded Releases directory."
            }
        }


        // Stage 3: Fetch the developer-specific configuration files from another repository.
        stage('Gather Developer Configs') {
            echo "Fetching developer configuration repository..."
            
            def devConfigRepoUrl = 'https://github.com/onex-saksham/ODP-configs.git'

            dir('temp_config_repo') {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    userRemoteConfigs: [[url: devConfigRepoUrl]]
                ])
            }

            echo "Successfully checked out developer configuration repository."
        }

        stage('Fetch Passwords from Vault') {
            echo "Fetching passwords from Vault and creating deployment/Script/passwords.json..."

            // Define local output file
            def PASSWORDS_FILE = "deployment/Script/passwords.json"

            // Use Jenkins credential for Vault token
            withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
                // Vault endpoint and secret path
                def vaultAddr = "http://localhost:8200"
                def vaultPath = "secret/data/deployment/node/test/passwords"

                // Fetch secret data from Vault KV v2
                def vaultResponse = sh(
                    script: """
                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
                            ${vaultAddr}/v1/${vaultPath}
                    """,
                    returnStdout: true
                ).trim()

                if (!vaultResponse?.trim()) {
                    error "Vault returned empty response for path: ${vaultPath}"
                }

                // Parse Vault response JSON
                def vaultJson
                try {
                    vaultJson = readJSON text: vaultResponse
                } catch (Exception e) {
                    error "Failed to parse Vault response: ${e.message}"
                }

                // Extract KV v2 data safely
                def passwordsData = null
                if (vaultJson?.data?.data) {
                    // KV v2 structure
                    passwordsData = vaultJson.data.data
                } else if (vaultJson?.data) {
                    // KV v1 fallback
                    passwordsData = vaultJson.data
                }

                if (!passwordsData) {
                    echo "DEBUG: Vault JSON keys = ${vaultJson?.keySet() ?: 'none'}"
                    error "Could not extract passwords map from Vault path: ${vaultPath}"
                }

                // Write the passwords as pretty JSON
                writeFile file: PASSWORDS_FILE, text: groovy.json.JsonOutput.prettyPrint(
                    groovy.json.JsonOutput.toJson(passwordsData)
                )
                echo "Successfully fetched and stored passwords.json at ${PASSWORDS_FILE}"
            }

            // Optional: verify the file exists
            if (!fileExists(PASSWORDS_FILE)) {
                error "passwords.json was not created successfully at ${PASSWORDS_FILE}"
            }
        }


                    // echo "Fetching passwords.json from Vault for ${params.TARGET_ENV} environment..."

                    // def PASSWORDS_FILE = "deployment/Script/passwords.json"

                    // // Use root token credential to fetch full secret JSON from Vault
                    // withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_ROOT_TOKEN')]) {
                    //     def vaultAddr = "http://localhost:8200"
                    //     def vaultPath = "secret/data/initialization/nodes/${params.TARGET_ENV.toLowerCase()}/passwords.json"

                    //     // Fetch the secret via Vault HTTP API
                    //     def vaultResponse = sh(
                    //         script: """
                    //             curl -s -H "X-Vault-Token: ${VAULT_ROOT_TOKEN}" \\
                    //                 ${vaultAddr}/v1/${vaultPath}
                    //         """,
                    //         returnStdout: true
                    //     ).trim()

                    //     if (!vaultResponse?.trim()) {
                    //         error "Vault returned empty response for path: ${vaultPath}"
                    //     }

                    //     // Parse response JSON safely
                    //     def vaultJson
                    //     try {
                    //         vaultJson = readJSON text: vaultResponse
                    //     } catch (Exception e) {
                    //         error "Failed to parse Vault response: ${e.message}"
                    //     }

                    //     // Extract password data from KV v2 response
                    //     def passwordsData = null
                    //     if (vaultJson?.data?.data) {
                    //         passwordsData = vaultJson.data.data
                    //     } else if (vaultJson?.data) {
                    //         passwordsData = vaultJson.data
                    //     }

                    //     if (!passwordsData) {
                    //         error "No passwords found under Vault path: ${vaultPath}"
                    //     }

                    //     echo "Fetched passwords for ${passwordsData.size()} nodes."
                    //     echo "Writing to ${PASSWORDS_FILE}..."

                    //     // Write out as pretty JSON
                    //     writeFile file: PASSWORDS_FILE, text: groovy.json.JsonOutput.prettyPrint(
                    //         groovy.json.JsonOutput.toJson(passwordsData)
                    //     )
                    // }

                    // echo "Successfully fetched and stored passwords.json at ${PASSWORDS_FILE}"


        // Stage 4: Merge all configurations into a single, final JSON file.
       stage('Prepare and Update Config') {
            echo "Copying master config file for ${params.TARGET_ENV} into the Script/ directory..."
            sh "cp deployment/configs/${params.TARGET_ENV.toLowerCase()}/initialization_deployment_config.json deployment/Script/"
            sh "cp deployment/configs/${params.TARGET_ENV.toLowerCase()}/smtp_config.json deployment/Script/"
            echo "Successfully loaded master configuration file."

            withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
                def vaultAddr = "http://localhost:8200"
                def vaultPath = "secret/data/jenkins/smtp"

                echo "Fetching SMTP password from Vault using root token..."

                def vaultResponse = sh(
                    script: """
                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
                            ${vaultAddr}/v1/${vaultPath}
                    """,
                    returnStdout: true
                ).trim()

                if (!vaultResponse?.trim()) {
                    error "Vault returned empty response for path: ${vaultPath}"
                }

                def vaultJson
                try {
                    vaultJson = readJSON text: vaultResponse
                } catch (Exception e) {
                    error "Failed to parse Vault response: ${e.message}"
                }

                def smtpSecret = vaultJson?.data?.data
                if (!smtpSecret || !smtpSecret['password']) {
                    error "SMTP password not found at Vault path: ${vaultPath}"
                }

                def SMTP_PASSWORD = smtpSecret['password']
                echo "Successfully fetched SMTP password from Vault (masked)."

                    script {
                    // Build the path to the correct developer config file based on the selected environment.
                    def masterConfigFile = 'deployment/Script/initialization_deployment_config.json'
                    def developerConfigFile = "temp_config_repo/deployment/${params.TARGET_ENV.toLowerCase()}/initialization_deployment_config_developers.json"                
                    
                    echo "Reading comprehensive developer configuration from ${developerConfigFile}..."
                    def developerConfig = readJSON file: developerConfigFile

                    // Extract the 'smtp' object and create a separate smtp_config.json file.
                    echo "Reading and updating master smtp_config.json..."
                    def smtpConfig = readJSON file: 'deployment/Script/smtp_config.json'
                    
                    if (developerConfig.smtp && developerConfig.smtp.recipients_email) {
                        smtpConfig.recipients_email = developerConfig.smtp.recipients_email
                    } else {
                        echo "WARN: 'recipients_email' not found in developerConfig.smtp. Using default from master."
                    }
                    smtpConfig.sender_password = SMTP_PASSWORD
                    
                    writeJSON file: 'deployment/Script/smtp_config.json', json: smtpConfig, pretty: 4
                    echo "Successfully created and secured smtp_config.json"
                    
                    // --- MERGE LOGIC ---
                    // Read the master template file that was copied earlier.
                    echo "Reading master configuration from ${masterConfigFile}..."
                    def config = readJSON file: masterConfigFile

                    config.deployment_path = developerConfig.deployment_path
                    config.ssh_port = developerConfig.ssh_port

                    if (!config.zookeeper) { config.zookeeper = [:] }
                    config.zookeeper.node_ip = developerConfig.zookeeper.node_ip
                    
                    if (!config.kafka) { config.kafka = [:] }
                    config.kafka.broker_ip = developerConfig.kafka.broker_ip
                    
                    if (!config.nifi) { config.nifi = [:] }
                    config.nifi.node_ip = developerConfig.nifi.node_ip
                    
                    if (!config.doris_fe) { config.doris_fe = [:] }
                    config.doris_fe.node_ip = developerConfig.doris_fe.node_ip

                    if (!config.doris_be) { config.doris_be = [:] }
                    config.doris_be.node_ip = developerConfig.doris_be.node_ip
                    
                    if (!config.monitoring) { config.monitoring = [:] }
                    config.monitoring.node_ip = developerConfig.monitoring.node_ip
                    config.monitoring.smtp = developerConfig.monitoring.smtp

                    if (!config.api) { config.api = [:] }
                    config.api.node_ip = developerConfig.api.node_ip
                    config.api.deployment_version = developerConfig.api.deployment_version
                    config.api.remote_jobs = developerConfig.api.remote_jobs
                    config.api.use_nginx = developerConfig.api.use_nginx
                    config.api.erlang_registry_ip = developerConfig.api.erlang_registry_ip
                    config.api.is_sa_seperate = developerConfig.api.is_sa_seperate
                    config.api.max_download_rows = developerConfig.api.max_download_rows
                    config.api.erlang_registry_url = developerConfig.api.erlang_registry_url
                    config.api.heartbeat_interval = developerConfig.api.heartbeat_interval
                    config.api.ports = developerConfig.api.ports

                    if (!config.backend_job) { config.backend_job = [:] }
                    config.backend_job.node_ip = developerConfig.backend_job.node_ip
                    config.backend_job.ID_DESC_URL = developerConfig.backend_job.ID_DESC_URL
                    config.backend_job.ZIP_HOST_IP = developerConfig.backend_job.ZIP_HOST_IP
                    config.backend_job.ZIP_USERNAME = developerConfig.backend_job.ZIP_USERNAME
                    config.backend_job.ZIP_SSH = developerConfig.backend_job.ZIP_SSH
                    config.backend_job.IS_SCP_REQUIRED = developerConfig.backend_job.IS_SCP_REQUIRED
                    config.backend_job.BACKEND_JOB_USER = developerConfig.backend_job.BACKEND_JOB_USER
                    config.backend_job.query_batch_size = developerConfig.backend_job.query_batch_size
                    
                    if (!config.schema_registry) { config.schema_registry = [:] }
                    config.schema_registry.node_ip = developerConfig.schema_registry.node_ip
                    
                    if (!config.nginx) { config.nginx = [:] }
                    config.nginx.node_ip = developerConfig.nginx.node_ip
                    
                    echo "Finished applying developer overrides."

                    // --- APPLY BUILD PARAMETERS ---
                    // Override the configuration with values selected in the Jenkins UI.
                    echo "Updating final configuration with build parameters..."
                    
                    if (!config.releases) { config.releases = [:] }
                    if (!config.deploy) { config.deploy = [:] }
                    
                    config.releases.new_version = params.DEPLOY_VERSION                
                    config.deploy_sms = params.SMS.toString()
                    config.deploy_rcs = params.RCS.toString()
                    config.deploy_whatsapp = params.Whatsapp.toString()

                    // Create a list of all services to loop through.
                    def services = [
                        'ZOOKEEPER', 'KAFKA', 'NIFI', 'NIFI_REGISTRY', 'DORIS_FE', 'DORIS_BE', 
                        'CONNECT_FE_BE', 'NODE_EXPORTER', 'KAFKA_EXPORTER', 'PROMETHEUS', 
                        'GRAFANA','HEALTH_REPORTS', 'RECON', 'JOBS', 'API', 'NGINX', 'SCHEMA_REGISTRY'
                    ]
                    
                    if (params.Select_All) {
                        echo "Select_All is selected. Overriding individual service selections."
                    }

                    // Sets deploy values in true or false
                    services.each { serviceName ->
                        def jsonKey = serviceName.toLowerCase().replace(' ', '_')
                        def paramValue = params.Select_All ? true : params[serviceName]
                        
                        echo " - Setting service '${jsonKey}' to '${paramValue}'"
                        config.deploy[jsonKey] = paramValue.toString()
                    }
                    
                    echo "Writing final updated configuration back to ${masterConfigFile}..."
                    writeJSON file: masterConfigFile, json: config, pretty: 4
                    
                    echo "Successfully updated initialization_deployment_config.json."
                }
            }
        }        

        // Stage 5: Manual approval gate.
        stage('Parameter Validation') {
            echo "Displaying updated configuration for validation:"
            
            script {
                // Read the content of each file into a Groovy variable.
                def passwordsContent = readFile('deployment/Script/passwords.json')
                def initContent = readFile('deployment/Script/initialization_deployment_config.json')

                // --- MASKING LOGIC FOR SMTP CONFIG ---
                // 1. Read the smtp_config.json file as a JSON object.
                def smtpData = readJSON file: 'deployment/Script/smtp_config.json'
                // 2. Overwrite the sensitive password field with a placeholder.
                smtpData.sender_password = '**** MASKED FOR SECURITY ****'
                // 3. Convert the modified object back into a nicely formatted string for display.
                def maskedSmtpContent = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(smtpData))


                // The 'input' step creates the "Proceed" button in the Jenkins UI.
                input(
                    // Construct a multi-line message string that includes all three file contents.
                    message: """Please review the deployment configuration below. Do you want to proceed?

-------------------- passwords.json --------------------
${passwordsContent}
-------------------- smtp_config.json (Masked) --------------------
${maskedSmtpContent}
-------------------- initialization_deployment_config.json --------------------
${initContent}
""",
                    ok: 'Yes, Proceed with Deployment' 
                )
            }
            
            echo "Validation approved. Continuing to the next stage..."
        }

        // Stage 6: Placeholder for any automated tests.
        stage('Test Cases (Planned)') {
            echo "SUCCESS: Placeholder stage for automated tests."
        }

        // Stage 7: The main deployment execution.
        stage('Deployment Execution') {
            echo "Preparing SSH key and Python environment..."
            
            withVault(vaultSecrets: [
                [path: 'initialization/jenkins/ssh_key', engineVersion: 2, secretValues: [
                    [envVar: 'SSH_KEY_CONTENT', vaultKey: 'key']
                ]]
            ], vaultCredentialId: 'vault-root-token')
            {
                try {
                    // Change the current directory to where the Python script is.
                    dir('deployment/Script') {
                        sh '''
                            echo "Setting up temporary SSH key..."
                            mkdir -p /home/jenkins/.ssh
                            cp "$SSH_KEY_FILE" /home/jenkins/.ssh/id_rsa
                            chmod 600 /home/jenkins/.ssh/id_rsa
                            
                            echo "Creating Python virtual environment..."
                            python3 -m venv venv

                            echo "Installing dependencies..."
                            venv/bin/pip install -r requirements.txt
                            
                            echo "Running the deployment script..."
                            export LOG_TO_CONSOLE=true
                            venv/bin/python3 deployment.py
                        '''
                    }
                } finally {
                    echo "Cleaning up temporary SSH key..."
                    sh 'rm -rf /home/jenkins/.ssh'
                }
            }
        }

        // Stage 8: Placeholder for post-deployment validation.
        stage('Validation (Planned)') {
            echo "SUCCESS: Placeholder stage for post-deployment validation."
        }

    } catch (e) {
        // If any stage in the 'try' block fails, this 'catch' block will execute.
        echo "An error occurred during the pipeline execution: ${e.getMessage()}"
        currentBuild.result = 'FAILURE'
        error("Pipeline failed")
    } 
}
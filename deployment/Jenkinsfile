node {
    // Define the parameters that will be presented to the user in the Jenkins UI
    // when they click "Build with Parameters".
    properties([
        parameters([
            booleanParam(name: 'SMS', defaultValue: false),
            booleanParam(name: 'RCS', defaultValue: false),
            booleanParam(name: 'Whatsapp', defaultValue: false),

            // == Environment Selection ==
            choice(name: 'TARGET_ENV', choices: ['Multi','Test', 'Airtel_dr', 'Dev', 'Single', 'QA', 'Prod', 'SBI_prod', 'SMPP_DR', 'Functional_Lab'], description: 'Select the target environment for deployment.'),
            // string(name: 'DEPLOY_VERSION', defaultValue: '1.0.0', description: 'Enter the version to deploy (e.g., 1.2.3).'),


            // == Service Selection Toggles ==
            booleanParam(name: 'Select_All', defaultValue: false, description: 'Select this to deploy all application services (Zookeeper to Nginx).'),
            booleanParam(name: 'ZOOKEEPER', defaultValue: false),
            booleanParam(name: 'KAFKA', defaultValue: false),
            booleanParam(name: 'NIFI', defaultValue: false),
            booleanParam(name: 'NIFI_REGISTRY', defaultValue: false),
            booleanParam(name: 'DORIS_FE', defaultValue: false),
            booleanParam(name: 'DORIS_BE', defaultValue: false),
            booleanParam(name: 'CONNECT_FE_BE', defaultValue: false),
            booleanParam(name: 'NODE_EXPORTER', defaultValue: false),
            booleanParam(name: 'KAFKA_EXPORTER', defaultValue: false),
            booleanParam(name: 'PROMETHEUS', defaultValue: false),
            booleanParam(name: 'GRAFANA', defaultValue: false),
            booleanParam(name: 'HEALTH_REPORTS', defaultValue: false),
            booleanParam(name: 'RECON', defaultValue: false),
            booleanParam(name: 'JOBS', defaultValue: false),
            booleanParam(name: 'API', defaultValue: false),
            booleanParam(name: 'NGINX', defaultValue: false),
            booleanParam(name: 'SCHEMA_REGISTRY', defaultValue: false)
        ])
    ])

    try {
        // Stage 1: Check out the primary source code (the repo containing this Jenkinsfile).
        stage('Initialization') {
            echo "Pipeline started for environment: ${params.TARGET_ENV}"
            checkout scm
        }

        // Stage 2: Fetch large binary files ('Releases') from a separate private repository.
        // This uses Git LFS (Large File Storage).
        // stage('Gather Source Files') {
        //     echo "Fetching Releases folder from private repo..."

        //     dir('temp_private_repo') {
        //         // Use Jenkins Vault root token to fetch GitHub credentials
        //         withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
        //             def vaultAddr = "http://localhost:8200"
        //             def vaultPath = "secret/data/jenkins/github"

        //             echo "Fetching GitHub credentials from Vault (${vaultAddr}/v1/${vaultPath})..."

        //             // Securely fetch Vault secret
        //             def vaultResponse = sh(
        //                 script: """
        //                     curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
        //                         ${vaultAddr}/v1/${vaultPath}
        //                 """,
        //                 returnStdout: true
        //             ).trim()

        //             if (!vaultResponse) {
        //                 error "Vault returned empty response for path: ${vaultPath}"
        //             }

        //             def vaultJson = readJSON text: vaultResponse
        //             def githubData = vaultJson?.data?.data

        //             if (!githubData || !githubData['username'] || !githubData['token']) {
        //                 error "Missing username/token fields in Vault secret at ${vaultPath}"
        //             }

        //             def GITHUB_USER = githubData['username']
        //             def GITHUB_TOKEN = githubData['token']

        //             echo "Successfully retrieved GitHub credentials from Vault."

        //             // Configure Git LFS for authenticated pull
        //             sh "git config --global lfs.https://github.com/1xtel/ODP.git.header 'Authorization: token ${GITHUB_TOKEN}'"

        //             // Clean previous repo state (avoids remote conflict)
        //             sh "rm -rf .git"

        //             // Perform sparse checkout of Releases directory
        //             def gitUrl = "https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/1xtel/ODP.git"
        //             sh """
        //                 git init
        //                 git remote add origin ${gitUrl}
        //                 git config core.sparseCheckout true
        //                 echo "Jenkins/deployment-pipeline/Releases/" > .git/info/sparse-checkout
        //                 git pull origin main --depth=1
        //             """

        //             // Cleanup sensitive Git config
        //             sh "git config --global --unset lfs.https://github.com/1xtel/ODP.git.header"
        //         }

        //         // Copy Releases folder into workspace root (same as original behavior)
        //         echo "Copying Releases folder to the workspace root..."
        //         sh """
        //             cd /home/jenkins/workspace/deployment-pipeline-groovy/deployment
        //             mkdir -p Releases
        //             cp -r ../temp_private_repo/Jenkins/deployment-pipeline/Releases/* ./Releases/
        //         """

        //         echo "Successfully loaded Releases directory."
        //     }
        // }



        // // Stage 3: Fetch the developer-specific configuration files from another repository.
        // stage('Gather Developer Configs') {
        //     echo "Fetching developer configuration repository..."
            
        //     def devConfigRepoUrl = 'https://github.com/onex-saksham/ODP-configs.git'

        //     dir('temp_config_repo') {
        //         checkout([
        //             $class: 'GitSCM',
        //             branches: [[name: '*/main']],
        //             userRemoteConfigs: [[url: devConfigRepoUrl]]
        //         ])
        //     }

        //     echo "Successfully checked out developer configuration repository."
        // }
        stage('Gather Developer Configs') {
            echo "Fetching developer configuration directory from main 1xtel/ODP repository..."

            // Updated to use 1xtel/ODP.git (main repo)
            def devConfigRepoUrl = 'https://github.com/1xtel/ODP.git'

            dir('temp_config_repo') {
                // Pull only the odp-config directory using sparse checkout for efficiency
                withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
                    def vaultAddr = "http://localhost:8200"
                    def vaultPath = "secret/data/jenkins/github"

                    echo "Fetching GitHub credentials from Vault (${vaultAddr}/v1/${vaultPath})..."
                    def vaultResponse = sh(
                        script: """
                            curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
                                ${vaultAddr}/v1/${vaultPath}
                        """,
                        returnStdout: true
                    ).trim()

                    if (!vaultResponse) {
                        error "Vault returned empty response for path: ${vaultPath}"
                    }

                    def vaultJson = readJSON text: vaultResponse
                    def githubData = vaultJson?.data?.data

                    if (!githubData || !githubData['username'] || !githubData['token']) {
                        error "Missing username/token fields in Vault secret at ${vaultPath}"
                    }

                    def GITHUB_USER = githubData['username']
                    def GITHUB_TOKEN = githubData['token']
                    echo "Successfully retrieved GitHub credentials from Vault."

                    // Perform sparse checkout for odp-config directory only
                    def gitUrl = "https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/1xtel/ODP.git"
                    sh """
                        git init
                        git remote add origin ${gitUrl}
                        git config core.sparseCheckout true
                        echo "Jenkins/odp-config/deployment" > .git/info/sparse-checkout
                        git pull origin main --depth=1
                    """
                    
                    echo "Normalizing odp-config directory structure..."
                    sh """
                        mkdir -p deployment
                        cp -r Jenkins/odp-config/deployment/* deployment/
                    """
                }
            }

            echo "Successfully fetched odp-config directory from 1xtel/ODP repository."
        }

        stage('Fetch Passwords from Vault') {
            echo "Fetching passwords from Vault and creating deployment/Script/passwords.json..."

            // Define local output file
            def PASSWORDS_FILE = "deployment/Script/passwords.json"

            // Use Jenkins credential for Vault token
            withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
                // Vault endpoint and secret path
                def vaultAddr = "http://localhost:8200"
                def vaultPath = "secret/data/deployment/node/${params.TARGET_ENV.toLowerCase()}/passwords"

                // Fetch secret data from Vault KV v2
                def vaultResponse = sh(
                    script: """
                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
                            ${vaultAddr}/v1/${vaultPath}
                    """,
                    returnStdout: true
                ).trim()

                if (!vaultResponse?.trim()) {
                    error "Vault returned empty response for path: ${vaultPath}"
                }

                // Parse Vault response JSON
                def vaultJson
                try {
                    vaultJson = readJSON text: vaultResponse
                } catch (Exception e) {
                    error "Failed to parse Vault response: ${e.message}"
                }

                // Extract KV v2 data safely
                def passwordsData = null
                if (vaultJson?.data?.data) {
                    // KV v2 structure
                    passwordsData = vaultJson.data.data
                } else if (vaultJson?.data) {
                    // KV v1 fallback
                    passwordsData = vaultJson.data
                }

                if (!passwordsData) {
                    echo "DEBUG: Vault JSON keys = ${vaultJson?.keySet() ?: 'none'}"
                    error "Could not extract passwords map from Vault path: ${vaultPath}"
                }

                // Write the passwords as pretty JSON
                writeFile file: PASSWORDS_FILE, text: groovy.json.JsonOutput.prettyPrint(
                    groovy.json.JsonOutput.toJson(passwordsData)
                )
                echo "Successfully fetched and stored passwords.json at ${PASSWORDS_FILE}"
            }

            // Optional: verify the file exists
            if (!fileExists(PASSWORDS_FILE)) {
                error "passwords.json was not created successfully at ${PASSWORDS_FILE}"
            }
        }
        
        // Stage 4: Merge all configurations into a single, final JSON file.
       stage('Prepare and Update Config') {
            echo "Copying master config file for ${params.TARGET_ENV} into the Script/ directory..."
            sh "cp deployment/configs/${params.TARGET_ENV.toLowerCase()}/initialization_deployment_config.json deployment/Script/"
            sh "cp deployment/configs/${params.TARGET_ENV.toLowerCase()}/smtp_config.json deployment/Script/"
            echo "Successfully loaded master configuration file."

            withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
                def vaultAddr = "http://localhost:8200"
                def vaultPath = "secret/data/jenkins/smtp"

                echo "Fetching SMTP password from Vault using root token..."

                def vaultResponse = sh(
                    script: """
                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
                            ${vaultAddr}/v1/${vaultPath}
                    """,
                    returnStdout: true
                ).trim()

                if (!vaultResponse?.trim()) {
                    error "Vault returned empty response for path: ${vaultPath}"
                }

                def vaultJson
                try {
                    vaultJson = readJSON text: vaultResponse
                } catch (Exception e) {
                    error "Failed to parse Vault response: ${e.message}"
                }

                def smtpSecret = vaultJson?.data?.data
                if (!smtpSecret || !smtpSecret['password']) {
                    error "SMTP password not found at Vault path: ${vaultPath}"
                }

                def SMTP_PASSWORD = smtpSecret['password']
                echo "Successfully fetched SMTP password from Vault (masked)."

                    script {
                    // Build the path to the correct developer config file based on the selected environment.
                    def masterConfigFile = 'deployment/Script/initialization_deployment_config.json'
                    def developerConfigFile = "temp_config_repo/deployment/${params.TARGET_ENV.toLowerCase()}/deployment_config_developers.json"                
                    
                    echo "Reading comprehensive developer configuration from ${developerConfigFile}..."
                    def developerConfig = readJSON file: developerConfigFile

                    // Extract the 'smtp' object and create a separate smtp_config.json file.
                    echo "Reading and updating master smtp_config.json..."
                    def smtpConfig = readJSON file: 'deployment/Script/smtp_config.json'
                    
                    if (developerConfig.smtp && developerConfig.smtp.recipients_email) {
                        smtpConfig.recipients_email = developerConfig.smtp.recipients_email
                    } else {
                        echo "WARN: 'recipients_email' not found in developerConfig.smtp. Using default from master."
                    }
                    smtpConfig.sender_password = SMTP_PASSWORD
                    
                    writeJSON file: 'deployment/Script/smtp_config.json', json: smtpConfig, pretty: 4
                    echo "Successfully created and secured smtp_config.json"
                    
                    // --- MERGE LOGIC ---
                    // Read the master template file that was copied earlier.
                    echo "Reading master configuration from ${masterConfigFile}..."
                    def config = readJSON file: masterConfigFile

                    config.deployment_path = developerConfig.deployment_path
                    config.ssh_port = developerConfig.ssh_port

                    if (!config.zookeeper) { config.zookeeper = [:] }
                    config.zookeeper.node_ip = developerConfig.zookeeper.node_ip
                    
                    if (!config.kafka) { config.kafka = [:] }
                    config.kafka.broker_ip = developerConfig.kafka.broker_ip
                    
                    if (!config.nifi) { config.nifi = [:] }
                    config.nifi.node_ip = developerConfig.nifi.node_ip
                    
                    if (!config.doris_fe) { config.doris_fe = [:] }
                    config.doris_fe.node_ip = developerConfig.doris_fe.node_ip

                    if (!config.doris_be) { config.doris_be = [:] }
                    config.doris_be.node_ip = developerConfig.doris_be.node_ip
                    
                    if (!config.monitoring) { config.monitoring = [:] }
                    config.monitoring.node_ip = developerConfig.monitoring.node_ip
                    config.monitoring.smtp.password = SMTP_PASSWORD

                    if (!config.api) { config.api = [:] }
                    config.api.node_ip = developerConfig.api.node_ip
                    config.api.deployment_version = developerConfig.api.deployment_version
                    config.api.remote_jobs = developerConfig.api.remote_jobs
                    config.api.use_nginx = developerConfig.api.use_nginx
                    config.api.erlang_registry_ip = developerConfig.api.erlang_registry_ip
                    config.api.is_sa_seperate = developerConfig.api.is_sa_seperate
                    config.api.max_download_rows = developerConfig.api.max_download_rows
                    config.api.erlang_registry_url = developerConfig.api.erlang_registry_url
                    config.api.heartbeat_interval = developerConfig.api.heartbeat_interval

                    if (!config.backend_job) { config.backend_job = [:] }
                    config.backend_job.node_ip = developerConfig.backend_job.node_ip
                    config.backend_job.ID_DESC_URL = developerConfig.backend_job.ID_DESC_URL
                    config.backend_job.ZIP_HOST_IP = developerConfig.backend_job.ZIP_HOST_IP
                    config.backend_job.ZIP_USERNAME = developerConfig.backend_job.ZIP_USERNAME
                    config.backend_job.ZIP_SSH = developerConfig.backend_job.ZIP_SSH
                    config.backend_job.IS_SCP_REQUIRED = developerConfig.backend_job.IS_SCP_REQUIRED
                    config.backend_job.BACKEND_JOB_USER = developerConfig.backend_job.BACKEND_JOB_USER
                    config.backend_job.query_batch_size = developerConfig.backend_job.query_batch_size
                    
                    if (!config.schema_registry) { config.schema_registry = [:] }
                    config.schema_registry.node_ip = developerConfig.schema_registry.node_ip
                    
                    if (!config.nginx) { config.nginx = [:] }
                    config.nginx.node_ip = developerConfig.nginx.node_ip
                    
                    echo "Finished applying developer overrides."

                    // --- APPLY BUILD PARAMETERS ---
                    // Override the configuration with values selected in the Jenkins UI.
                    echo "Updating final configuration with build parameters..."
                    
                    // if (!config.releases) { config.releases = [:] }
                    if (!config.deploy) { config.deploy = [:] }
                    
                    // config.releases.new_version = params.DEPLOY_VERSION                
                    config.deploy_sms = params.SMS.toString()
                    config.deploy_rcs = params.RCS.toString()
                    config.deploy_whatsapp = params.Whatsapp.toString()

                    // Create a list of all services to loop through.
                    def services = [
                        'ZOOKEEPER', 'KAFKA', 'NIFI', 'NIFI_REGISTRY', 'DORIS_FE', 'DORIS_BE', 
                        'CONNECT_FE_BE', 'NODE_EXPORTER', 'KAFKA_EXPORTER', 'PROMETHEUS', 
                        'GRAFANA','HEALTH_REPORTS', 'RECON', 'JOBS', 'API', 'NGINX', 'SCHEMA_REGISTRY'
                    ]
                    
                    if (params.Select_All) {
                        echo "Select_All is selected. Overriding individual service selections."
                    }

                    // Sets deploy values in true or false
                    services.each { serviceName ->
                        def jsonKey = serviceName.toLowerCase().replace(' ', '_')
                        def paramValue = params.Select_All ? true : params[serviceName]
                        
                        echo " - Setting service '${jsonKey}' to '${paramValue}'"
                        config.deploy[jsonKey] = paramValue.toString()
                    }
                    
                    echo "Writing final updated configuration back to ${masterConfigFile}..."
                    writeJSON file: masterConfigFile, json: config, pretty: 4
                    
                    echo "Successfully updated initialization_deployment_config.json."
                }
            }
        }        

        // Stage 5: Manual approval gate.
        stage('Parameter Validation') {
            echo "Displaying updated configuration for validation:"
            
            script {
                // Read the content of each file into a Groovy variable.
                def passwordsContent = readFile('deployment/Script/passwords.json')
                def initContent = readFile('deployment/Script/initialization_deployment_config.json')

                // --- MASKING LOGIC FOR SMTP CONFIG ---
                // 1. Read the smtp_config.json file as a JSON object.
                def smtpData = readJSON file: 'deployment/Script/smtp_config.json'
                // 2. Overwrite the sensitive password field with a placeholder.
                smtpData.sender_password = '**** MASKED FOR SECURITY ****'
                // 3. Convert the modified object back into a nicely formatted string for display.
                def maskedSmtpContent = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(smtpData))


                // The 'input' step creates the "Proceed" button in the Jenkins UI.
                input(
                    // Construct a multi-line message string that includes all three file contents.
                    message: """Please review the deployment configuration below. Do you want to proceed?

-------------------- passwords.json --------------------
${passwordsContent}
-------------------- smtp_config.json (Masked) --------------------
${maskedSmtpContent}
-------------------- initialization_deployment_config.json --------------------
${initContent}
""",
                    ok: 'Yes, Proceed with Deployment' 
                )
            }
            
            echo "Validation approved. Continuing to the next stage..."
        }

        // Stage 6: Placeholder for any automated tests.
        stage('Test Cases (Planned)') {
            echo "SUCCESS: Placeholder stage for automated tests."
        }

        // Stage 7: The main deployment execution.
        stage('Deployment Execution') {
            echo "Preparing SSH key and Python environment..."

            withCredentials([string(credentialsId: 'vault-root-token', variable: 'VAULT_TOKEN')]) {
                def vaultAddr = "http://localhost:8200"
                def vaultPath = "secret/data/initialization/jenkins/ssh_key"

                echo "Fetching SSH private key from Vault using root token..."

                def vaultResponse = sh(
                    script: """
                        curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \\
                            ${vaultAddr}/v1/${vaultPath}
                    """,
                    returnStdout: true
                ).trim()

                if (!vaultResponse?.trim()) {
                    error "Vault returned empty response for path: ${vaultPath}"
                }

                def vaultJson
                try {
                    vaultJson = readJSON text: vaultResponse
                } catch (Exception e) {
                    error "Failed to parse Vault response: ${e.message}"
                }

                def sshSecret = vaultJson?.data?.data
                if (!sshSecret || !sshSecret['ssh-key']) {
                    error "SSH key not found at Vault path: ${vaultPath}"
                }

                def SSH_KEY_CONTENT = sshSecret['ssh-key']
                echo "Successfully fetched SSH key from Vault (masked)."

                script {
                    try {
                        dir('deployment/Script') {
                            sh """
                                echo "Setting up temporary SSH key..."
                                mkdir -p /home/jenkins/.ssh
                                echo '${SSH_KEY_CONTENT}' > /home/jenkins/.ssh/id_rsa
                                chmod 600 /home/jenkins/.ssh/id_rsa

                                echo "Disabling strict host key checking for automated SSH..."                                
                                chmod 600 /home/jenkins/.ssh/config

                                echo "Creating Python virtual environment..."
                                python3 -m venv venv

                                echo "Installing dependencies..."
                                venv/bin/pip install -r requirements.txt

                                echo "Running the deployment script..."
                                export LOG_TO_CONSOLE=true
                                venv/bin/python3 deployment.py 2>&1
                                cat deployment.log
                            """
                        }
                    } finally {
                        echo "Deployment.py execution completed..."
                    }
                }
            }
        }


        // Stage 8: Placeholder for post-deployment validation.
        stage('Validation (Planned)') {
            echo "SUCCESS: Placeholder stage for post-deployment validation."
        }

    } catch (e) {
        // If any stage in the 'try' block fails, this 'catch' block will execute.
        echo "An error occurred during the pipeline execution: ${e.getMessage()}"
        currentBuild.result = 'FAILURE'
        error("Pipeline failed")
    } 
    finally {        
        // echo "Pipeline run finished. Cleaning up workspace..."
        // cleanWs()
    }
}
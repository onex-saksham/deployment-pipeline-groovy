node {
    // Define the parameters that will be presented to the user in the Jenkins UI
    // when they click "Build with Parameters".
    properties([
        parameters([
            booleanParam(name: 'SMS', defaultValue: false),
            booleanParam(name: 'RCS', defaultValue: false),
            booleanParam(name: 'Whatsapp', defaultValue: false),

            // == Environment and Version Selection ==
            choice(name: 'TARGET_ENV', choices: ['Dev', 'Single', 'QA', 'Prod', 'SBI Prod', 'SMPP DR', 'Functional Lab'], description: 'Select the target environment for deployment.'),
            string(name: 'DEPLOY_VERSION', defaultValue: '1.0.0', description: 'Enter the version to deploy (e.g., 1.2.3).'),


            // == Service Selection Toggles ==
            booleanParam(name: 'Select_All', defaultValue: false, description: 'Select this to deploy all application services (Zookeeper to Nginx).'),
            booleanParam(name: 'ZOOKEEPER', defaultValue: false),
            booleanParam(name: 'KAFKA', defaultValue: false),
            booleanParam(name: 'NIFI', defaultValue: false),
            booleanParam(name: 'NIFI_REGISTRY', defaultValue: false),
            booleanParam(name: 'DORIS_FE', defaultValue: false),
            booleanParam(name: 'DORIS_BE', defaultValue: false),
            booleanParam(name: 'CONNECT_FE_BE', defaultValue: false),
            booleanParam(name: 'NODE_EXPORTER', defaultValue: false),
            booleanParam(name: 'KAFKA_EXPORTER', defaultValue: false),
            booleanParam(name: 'PROMETHEUS', defaultValue: false),
            booleanParam(name: 'GRAFANA', defaultValue: false),
            booleanParam(name: 'HEALTH_REPORTS', defaultValue: false),
            booleanParam(name: 'RECON', defaultValue: false),
            booleanParam(name: 'JOBS', defaultValue: false),
            booleanParam(name: 'API', defaultValue: false),
            booleanParam(name: 'NGINX', defaultValue: false),
            booleanParam(name: 'SCHEMA_REGISTRY', defaultValue: false)
        ])
    ])

    try {
        // Stage 1: Check out the primary source code (the repo containing this Jenkinsfile).
        stage('Initialization') {
            echo "Pipeline started for environment: ${params.TARGET_ENV}"
            checkout scm
        }

        // Stage 2: Fetch large binary files ('Releases') from a separate private repository.
        // This uses Git LFS (Large File Storage).
        stage('Gather Source Files') {
            echo "Fetching Releases folder from private repo..."
            dir('temp_private_repo') {
                withCredentials([usernamePassword(credentialsId: 'private-github-token', passwordVariable: 'GITHUB_TOKEN', usernameVariable: 'GITHUB_USER')]) {
                    sh 'git config --global lfs.https://github.com/1xtel/ODP.git.header "Authorization: token ${GITHUB_TOKEN}"'


                    // Perform a "sparse checkout" to only download the 'Releases' directory.
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/main']],
                        userRemoteConfigs: [[
                            url: 'https://github.com/1xtel/ODP.git',
                            credentialsId: 'private-github-token'
                        ]],
                        extensions: [
                            [$class: 'GitLFSPull'],
                            [$class: 'SparseCheckoutPaths', sparseCheckoutPaths: [
                                [path: 'Jenkins/deployment-pipeline/Releases/']
                            ]]
                        ]
                    ])
                    // Clean up the temporary LFS authentication configuration for security.
                    sh 'git config --global --unset lfs.https://github.com/1xtel/ODP.git.header'
                }
            }

            // Copy the downloaded 'Releases' folder into the correct 'deployment' directory.
            echo "Copying Releases folder to the workspace root..."
            sh "cp -r temp_private_repo/Jenkins/deployment-pipeline/Releases ./deployment/"

            echo "Successfully loaded Releases directory."
        }

        // Stage 3: Fetch the developer-specific configuration files from another repository.
        stage('Gather Developer Configs') {
            echo "Fetching developer configuration repository..."
            
            def devConfigRepoUrl = 'https://github.com/onex-saksham/ODP-configs.git'

            dir('temp_config_repo') {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    userRemoteConfigs: [[url: devConfigRepoUrl]]
                ])
            }

            echo "Successfully checked out developer configuration repository."
        }

        // Stage 4: Merge all configurations into a single, final JSON file.
       stage('Prepare and Update Config') {
            // Copy the master template for the selected environment into the 'Script' directory.
            echo "Copying master config file for ${params.TARGET_ENV} into the Script/ directory..."
            sh "cp deployment/configs/${params.TARGET_ENV.toLowerCase()}/initialization_deployment_config.json deployment/Script/"
            echo "Successfully loaded master configuration file."

            script {
                def masterConfigFile = 'deployment/Script/initialization_deployment_config.json'
                // Build the path to the correct developer config file based on the selected environment.
                def developerConfigFile = "temp_config_repo/deployment/${params.TARGET_ENV.toLowerCase()}/initialization_deployment_config_developers.json"                
                
                echo "Reading comprehensive developer configuration from ${developerConfigFile}..."
                def developerConfig = readJSON file: developerConfigFile

                // --- DYNAMIC FILE CREATION ---
                // Extract the 'passwords' object from the developer config and create a separate passwords.json file.
                echo "Extracting password data..."
                def passwordsData = developerConfig.passwords
                if (!passwordsData) { error("Developer config is missing the 'passwords' object.") }
                writeJSON file: 'deployment/Script/passwords.json', json: passwordsData, pretty: 4
                echo "Successfully created passwords.json"


                // Extract the 'smtp' object and create a separate smtp_config.json file.
                echo "Extracting SMTP data..."
                def smtpData = developerConfig.smtp
                if (!smtpData) { error("Developer config is missing the 'smtp' object.") }
                writeJSON file: 'deployment/Script/smtp_config.json', json: smtpData, pretty: 4
                echo "Successfully created smtp_config.json"
                
                // --- MERGE LOGIC ---
                // Read the master template file that was copied earlier.
                echo "Reading master configuration from ${masterConfigFile}..."
                def config = readJSON file: masterConfigFile

                config.base_user = developerConfig.base_user
                config.user = developerConfig.user
                config.deployment_type = developerConfig.deployment_type
                config.deployment_path = developerConfig.deployment_path
                config.ssh_port = developerConfig.ssh_port

                if (!config.zookeeper) { config.zookeeper = [:] }
                config.zookeeper.node_ip = developerConfig.zookeeper.node_ip
                
                if (!config.kafka) { config.kafka = [:] }
                config.kafka.broker_ip = developerConfig.kafka.broker_ip
                
                if (!config.nifi) { config.nifi = [:] }
                config.nifi.node_ip = developerConfig.nifi.node_ip
                
                if (!config.doris_fe) { config.doris_fe = [:] }
                config.doris_fe.node_ip = developerConfig.doris_fe.node_ip

                if (!config.doris_be) { config.doris_be = [:] }
                config.doris_be.node_ip = developerConfig.doris_be.node_ip
                
                if (!config.monitoring) { config.monitoring = [:] }
                config.monitoring.node_ip = developerConfig.monitoring.node_ip
                config.monitoring.smtp = developerConfig.monitoring.smtp

                if (!config.api) { config.api = [:] }
                config.api.node_ip = developerConfig.api.node_ip
                config.api.deployment_version = developerConfig.api.deployment_version
                config.api.remote_jobs = developerConfig.api.remote_jobs
                config.api.use_nginx = developerConfig.api.use_nginx
                config.api.erlang_registry_ip = developerConfig.api.erlang_registry_ip

                if (!config.backend_job) { config.backend_job = [:] }
                config.backend_job.node_ip = developerConfig.backend_job.node_ip
                config.backend_job.ID_DESC_URL = developerConfig.backend_job.ID_DESC_URL
                config.backend_job.ZIP_HOST_IP = developerConfig.backend_job.ZIP_HOST_IP
                config.backend_job.ZIP_USERNAME = developerConfig.backend_job.ZIP_USERNAME
                config.backend_job.ZIP_SSH = developerConfig.backend_job.ZIP_SSH
                config.backend_job.IS_SCP_REQUIRED = developerConfig.backend_job.IS_SCP_REQUIRED
                config.backend_job.BACKEND_JOB_USER = developerConfig.backend_job.BACKEND_JOB_USER
                
                if (!config.schema_registry) { config.schema_registry = [:] }
                config.schema_registry.node_ip = developerConfig.schema_registry.node_ip
                
                if (!config.nginx) { config.nginx = [:] }
                config.nginx.node_ip = developerConfig.nginx.node_ip
                
                echo "Finished applying developer overrides."

                // --- APPLY BUILD PARAMETERS ---
                // Override the configuration with values selected in the Jenkins UI.
                echo "Updating final configuration with build parameters..."
                
                if (!config.releases) { config.releases = [:] }
                if (!config.deploy) { config.deploy = [:] }
                
                config.releases.new_version = params.DEPLOY_VERSION                
                config.deploy_sms = params.SMS.toString()
                config.deploy_rcs = params.RCS.toString()
                config.deploy_whatsapp = params.Whatsapp.toString()

                // Create a list of all services to loop through.
                def services = [
                    'ZOOKEEPER', 'KAFKA', 'NIFI', 'NIFI_REGISTRY', 'DORIS_FE', 'DORIS_BE', 
                    'CONNECT_FE_BE', 'NODE_EXPORTER', 'KAFKA_EXPORTER', 'PROMETHEUS', 
                    'GRAFANA','HEALTH_REPORTS', 'RECON', 'JOBS', 'API', 'NGINX', 'SCHEMA_REGISTRY'
                ]
                
                if (params.Select_All) {
                    echo "Select_All is selected. Overriding individual service selections."
                }

                // Sets deploy values in true or false
                services.each { serviceName ->
                    def jsonKey = serviceName.toLowerCase().replace(' ', '_')
                    def paramValue = params.Select_All ? true : params[serviceName]
                    
                    echo " - Setting service '${jsonKey}' to '${paramValue}'"
                    config.deploy[jsonKey] = paramValue.toString()
                }
                
                echo "Writing final updated configuration back to ${masterConfigFile}..."
                writeJSON file: masterConfigFile, json: config, pretty: 4
                
                echo "Successfully updated initialization_deployment_config.json."
            }
        }

        // Stage 5: Manual approval gate.
        // This stage pauses the pipeline and waits for a human to confirm the configuration.        
        stage('Parameter Validation') {
            echo "Displaying updated configuration for validation:"
            
            sh 'cat deployment/Script/passwords.json'
            sh 'cat deployment/Script/smtp_config.json'
            sh 'cat deployment/Script/initialization_deployment_config.json'

            // The 'input' step creates the "Proceed" button in the Jenkins UI.            
            input(
                message: 'Please review the deployment configuration above. Do you want to proceed?',
                ok: 'Yes, Proceed with Deployment' 
            )
            
            echo "Validation approved. Continuing to the next stage..."
        }

        // Stage 6: Placeholder for any automated tests.
        stage('Test Cases (Planned)') {
            echo "SUCCESS: Placeholder stage for automated tests."
        }

        // Stage 7: The main deployment execution.
        stage('Deployment Execution') {
            echo "Preparing SSH key and Python environment..."
            
            withCredentials([sshUserPrivateKey(credentialsId: 'server-ssh-key', keyFileVariable: 'SSH_KEY_FILE')]) {
                try {
                    // Change the current directory to where the Python script is.
                    dir('deployment/Script') {
                        sh '''
                            echo "Setting up temporary SSH key..."
                            mkdir -p /home/jenkins/.ssh
                            cp "$SSH_KEY_FILE" /home/jenkins/.ssh/id_rsa
                            chmod 600 /home/jenkins/.ssh/id_rsa
                            
                            echo "Creating Python virtual environment..."
                            python3 -m venv venv

                            echo "Installing dependencies..."
                            venv/bin/pip install -r requirements.txt
                            
                            echo "Running the deployment script..."
                            export LOG_TO_CONSOLE=true
                            venv/bin/python3 deployment.py
                        '''
                    }
                } finally {
                    echo "Cleaning up temporary SSH key..."
                    sh 'rm -rf /home/jenkins/.ssh'
                }
            }
        }

        // Stage 8: Placeholder for post-deployment validation.
        stage('Validation (Planned)') {
            echo "SUCCESS: Placeholder stage for post-deployment validation."
        }

    } catch (e) {
        // If any stage in the 'try' block fails, this 'catch' block will execute.
        echo "An error occurred during the pipeline execution: ${e.getMessage()}"
        currentBuild.result = 'FAILURE'
        error("Pipeline failed")
    } 
}